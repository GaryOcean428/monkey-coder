#!/usr/bin/env python3
"""
Use Monkey Coder to generate context management system.
"""

import asyncio
import os
from pathlib import Path
from dotenv import load_dotenv
import sys
sys.path.insert(0, 'packages/core')

from monkey_coder.core.agent_executor import AgentExecutor
from monkey_coder.providers import ProviderRegistry
from monkey_coder.filesystem import write_file

# Load environment
env_path = Path('packages/core/.env.local')
if env_path.exists():
    load_dotenv(env_path)
    print(f'Loaded {env_path}')

async def generate_context_management():
    """Use Monkey Coder to generate context management."""
    registry = ProviderRegistry()
    await registry.initialize_all()
    executor = AgentExecutor(registry)
    
    print("=" * 60)
    print("MONKEY CODER GENERATING CONTEXT MANAGEMENT")
    print("=" * 60)
    
    # Generate context management implementation
    result = await executor.execute_agent_task(
        agent_type='architect',
        prompt="""Design and implement a complete context management system for multi-turn AI conversations with these requirements:

1. Conversation history storage:
   - Store messages by session_id
   - Include role (user/assistant/system)
   - Track token counts per message
   - Timestamp all messages

2. Context window management:
   - Calculate total tokens in context
   - Implement sliding window when exceeding limits
   - Prioritize recent and important messages
   - Summarize old messages when pruning

3. Session management:
   - Create/retrieve sessions by ID
   - Support multiple concurrent sessions
   - Session expiration and cleanup
   - Persist sessions to disk/database

4. Context retrieval:
   - Get full conversation history
   - Get context within token limits
   - Support semantic search for relevant context
   - Extract key information from history

5. Integration points:
   - Easy integration with agent executor
   - Support for different AI providers
   - Thread-safe for concurrent access

Include all necessary classes, methods, error handling, and make it production-ready.
Use asyncio for async operations and include proper type hints.""",
        provider='openai',
        model='gpt-4.1',
        max_tokens=4000
    )
    
    if result.get('status') == 'completed':
        code = result.get('output', '')
        
        # Extract Python code if wrapped in markdown
        if '```python' in code:
            start = code.find('```python') + 9
            end = code.find('```', start)
            if end > start:
                code = code[start:end].strip()
        
        # Save the context management implementation
        context_path = Path('packages/core/monkey_coder/context/manager.py')
        context_path.parent.mkdir(parents=True, exist_ok=True)
        
        write_file(str(context_path), code)
        print(f"\n✅ Generated context manager: {context_path}")
        print(f"   Size: {len(code)} bytes")
        
        # Generate __init__.py
        init_content = '''"""
Context management system for multi-turn conversations.
Generated by Monkey Coder using GPT-4.1.
"""

from .manager import (
    ContextManager,
    ConversationSession,
    Message,
    create_session,
    get_session,
)

__all__ = [
    "ContextManager",
    "ConversationSession",
    "Message",
    "create_session",
    "get_session",
]
'''
        
        init_path = context_path.parent / '__init__.py'
        write_file(str(init_path), init_content)
        print(f"✅ Created: {init_path}")
        
        return code
    else:
        raise Exception(f"Generation failed: {result.get('error')}")

async def main():
    try:
        code = await generate_context_management()
        print("\n" + "=" * 60)
        print("SUCCESS! Monkey Coder has generated context management!")
        print("=" * 60)
        
        # Show preview
        print("\nGenerated code preview:")
        print("-" * 40)
        lines = code.split('\n')[:30]
        for line in lines:
            print(line)
        if len(code.split('\n')) > 30:
            print("... (truncated)")
            
    except Exception as e:
        print(f"\n❌ Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())