Code Quality & Standards Rules

1. Multi-Persona Validation System: Before providing any solution, I should engage appropriate specialist personas (similar to .clinerules' {CODE_REVIEWER}, {SECURITY_SPECIALIST}, etc.) to validate different aspects:
‚Ä¢  Security concerns ‚Üí Security Specialist review
‚Ä¢  Performance implications ‚Üí Performance Optimizer review  
‚Ä¢  Architecture decisions ‚Üí Technical Architect validation
2. Duplication Prevention Protocol: Always check for existing similar functionality before creating new solutions. When replacement is necessary, follow a systematic approach:
‚Ä¢  Search thoroughly for existing implementations
‚Ä¢  Prefer extension/composition over duplication
‚Ä¢  Document reasons for replacements clearly
3. Thinking Process Documentation: Use structured thinking approaches:
‚Ä¢  {[thinking]} tags for planning
‚Ä¢  ```thinking code blocks for reasoning
‚Ä¢  Blockquotes for shorter planning notes
‚Ä¢  Clear problem ‚Üí analysis ‚Üí solution flow
4. Technical Standards Rules: Adhere to established coding standards and best practices:
‚Ä¢  Use mcp's like context7 to verify current LLM models, their API specifications and correct parameters.
‚Ä¢  Follow language-specific conventions (e.g., TypeScript, React)
‚Ä¢  Use consistent naming conventions
‚Ä¢  Implement proper error handling and loading states
‚Ä¢  Ensure code is modular and maintainable
‚Ä¢  Use comments judiciously to clarify complex logic
‚Ä¢  Maintain high test coverage and quality
‚Ä¢  Use version control effectively (e.g., Git)
‚Ä¢  Ensure code is well-documented and easy to understand and consistent with specification documentation. regularly clean up FIX.md files and guides. 
- Review the roadmap.md and update before any commits. use the docs folder, to store any documentation and fix files. cleanup unneded .md's if they are onetime use.

Technical Standards Rules

4. Version Requirements Enforcement: Maintain awareness of minimum version requirements and recommend current/supported versions:
‚Ä¢  Prioritize modern, well-supported versions
‚Ä¢  Check compatibility before recommendations
‚Ä¢  Warn about deprecated technologies
5. Build vs. Remove Philosophy: Default to building and completing features rather than removing unused code:
‚Ä¢  Investigate thoroughly before suggesting removals
‚Ä¢  Prioritize feature completion over cleanup
‚Ä¢  Understand project intent through documentation analysis
6. Environment-Aware Solutions: Consider different environments (dev, test, prod) in all recommendations and ensure solutions work across contexts.

Communication & Process Rules

7. Clear Task Understanding: Before executing any task, ensure complete understanding by:
‚Ä¢  Analyzing for ambiguities
‚Ä¢  Asking clarifying questions when needed  
‚Ä¢  Confirming intent before proceeding
‚Ä¢  Gathering relevant context from available sources
8. Systematic Investigation Protocol: When troubleshooting or analyzing issues:
‚Ä¢  Classify the problem type (build, deploy, runtime, etc.)
‚Ä¢  Investigate root causes systematically
‚Ä¢  Follow established error pattern recognition
‚Ä¢  Provide actionable solutions with clear steps
9. Documentation Standards: Always consider documentation impact:
‚Ä¢  Update relevant docs when suggesting changes
‚Ä¢  Maintain clear change records
‚Ä¢  Provide migration guidance for breaking changes
‚Ä¢  Use clear, professional communication

Security & Safety Rules

10. Security-First Approach: Always evaluate security implications:
‚ó¶  Validate input sanitization needs
‚ó¶  Consider authentication/authorization requirements
‚ó¶  Never compromise security for convenience
‚ó¶  Review for potential vulnerabilities
11. Careful Change Management: Only suggest changes that are:
‚ó¶  Well-understood and related to the request
‚ó¶  Thoroughly analyzed for side effects
‚ó¶  Documented with clear reasoning
‚ó¶  Tested or verifiable when possible

User Experience Rules

12. TypeScript & Modern Development Focus: When providing code solutions:
‚ó¶  Prioritize TypeScript with strict typing
‚ó¶  Use modern React patterns (functional components, hooks)
‚ó¶  Follow established naming conventions
‚ó¶  Implement proper error handling and loading states
13. Responsive & Accessible Design: Ensure recommendations consider:
‚ó¶  Cross-device compatibility
‚ó¶  Accessibility standards (ARIA attributes)
‚ó¶  Performance optimization
‚ó¶  User experience across different contexts

These rules would help me provide more structured, thorough, and professional assistance while maintaining high standards for code quality, security, and user experience. They emphasize systematic thinking, thorough analysis, and consideration of multiple perspectives before providing solutions.

## Railway Config Quick-Check (variable and reference variable Cheat-Sheet)

Follow this 8-step checklist every time you push or deploy a Railway project.

---

### 1. Pull the latest code  
```bash
git pull origin main
```

---

### 2. Open the three files that matter  
- `railway.toml` or `railway.json`  
- `Dockerfile` (if you use one)  
- Your main entry file (`server.js`, `app.py`, etc.)

---

### 3. Find or add the port line
| Language / Framework | Snippet to look for / insert |
|----------------------|------------------------------|
| Node.js (Express)    | `app.listen(process.env.PORT || 3000, '0.0.0.0')` |
| Next.js              | `"start": "next start --hostname 0.0.0.0 --port $PORT"` |
| Python (Flask)       | `app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)))` |
| Python (Uvicorn)     | `uvicorn main:app --host 0.0.0.0 --port $PORT` |

üîç **Checklist**  
- [ ] Uses `process.env.PORT` / `$PORT` / `os.getenv("PORT")`  
- [ ] Binds to `0.0.0.0` (or `::` for IPv6)  
- [ ] **No hard-coded port** like `3000` or `5000` alone

---

### 4. Verify inter-service URLs  
Replace any hard-coded hostnames or ports with Railway reference variables:

| Instead of ‚Ä¶                     | Use ‚Ä¶ |
|----------------------------------|-------|
| `http://localhost:4000`          | `http://${{api.RAILWAY_PRIVATE_DOMAIN}}:${{api.PORT}}` |
| `https://my-api.example.com`     | `https://${{api.RAILWAY_PUBLIC_DOMAIN}}` |

üîç **Checklist**  
- [ ] All internal traffic uses `http://` + `railway.internal` names  
- [ ] All public traffic uses `https://` + `RAILWAY_PUBLIC_DOMAIN`  
- [ ] **No** plain `localhost`, `127.0.0.1`, or raw IP addresses

---

### 5. CORS quick-scan (backend)  
Look for CORS middleware and ensure it contains:

```js
// Node.js / Express example
app.use(cors({
  origin: [process.env.FRONTEND_URL],   // or array of allowed origins
  credentials: true
}));
```

üîç **Checklist**  
- [ ] Origin list includes the exact deployed frontend URL(s)  
- [ ] `credentials: true` if you send cookies / auth headers  
- [ ] **Not** `origin: "*"` in production

---

### 6. WebSocket sanity check  
Client-side connection string must match protocol:

| Frontend origin | WebSocket URL |
|-----------------|---------------|
| `https://‚Ä¶`     | `wss://<backend>.up.railway.app/socket.io/` |
| `http://localhost` dev | `ws://localhost:<port>/socket.io/` |

üîç **Checklist**  
- [ ] **Never** mix `https` page with `ws://` (blocked by browser)  
- [ ] **Server-side** Socket.IO or WS library also has CORS/origin validation

---

### 7. Dockerfile (if used)  
Dockerfile should expose the port and accept build-time args:

```dockerfile
ARG PORT
EXPOSE ${PORT}
CMD ["node", "server.js"]
```

üîç **Checklist**  
- [ ] Uses `ARG PORT` if you need the port at build time  
- [ ] `EXPOSE` matches `$PORT`  
- [ ] Final `CMD` starts the app without hard-coding port

---

### 8. Deploy & test loop  
```bash
railway up
```
After each deploy:

- Open the **Railway dashboard ‚Üí Service ‚Üí Logs**  
- Confirm: `Listening on 0.0.0.0:<PORT>` (or `[::]:<PORT>`)  
- Hit the public URL or internal endpoint and verify 200/101 responses  
- Check browser console for CORS or WebSocket errors

---

**Done?** ‚úÖ Commit the fixed files and push.