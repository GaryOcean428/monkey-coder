# Monkey Coder Development Rules & Standards

*Consistent with Agent OS Standards (@~/.agent-os/standards/), CLAUDE.md, and docs/roadmap.md*

## Core Quality & Standards Rules

### 1. Multi-Persona Validation System
Before providing any solution, engage appropriate specialist personas to validate different aspects:
- Security concerns ‚Üí Security Specialist review (critical for Phase 1.6 Authentication System Unification)
- Performance implications ‚Üí Performance Optimizer review
- Architecture decisions ‚Üí Technical Architect validation

### 2. Duplication Prevention Protocol
Always check for existing similar functionality before creating new solutions:
- Search thoroughly for existing implementations
- Prefer extension/composition over duplication
- Document reasons for replacements clearly

### 3. Thinking Process Documentation
Use structured thinking approaches:
- `{[thinking]}` tags for planning
- ```thinking code blocks for reasoning
- Blockquotes for shorter planning notes
- Clear problem ‚Üí analysis ‚Üí solution flow

### 4. Technical Standards & Architecture Compliance
Adhere to Monkey Coder's established patterns and Agent OS standards:
- **Project Architecture**: Yarn 4.9.2 workspace monorepo with TypeScript CLI, Python FastAPI core
- **Package Management**: 
  - Use Yarn 4.9.2+ with Corepack enabled (`corepack enable && corepack prepare yarn@4.9.2 --activate`)
  - Global cache enabled for 30-50% faster installs
  - Hardlinks configured for node_modules performance
  - Workspace dependencies use `workspace:*` protocol
  - Constraints enforced via `yarn.config.cjs`
  - Run `yarn constraints` to check consistency
  - Run `yarn npm audit --all` for security checks
- **Python Management**: Python 3.13 for production, use uv then poetry before pip directly
- **MCP Integration**: Use MCPs like context7 to verify current LLM models, API specifications and parameters
- **Language Conventions**: 
  - TypeScript 5.8.3 with strict typing
  - Python type hints
  - React 18.2.0 functional patterns
  - Next.js 15.2.3 for web interface
- **Code Organization**: Maintain modular and maintainable structure consistent with packages/ layout
- **Error Handling**: Implement proper error handling and loading states
- **Documentation**: Keep code well-documented and consistent with specifications
- **File Management**: Use docs/ folder for documentation, cleanup unneeded .md files after one-time use
- **Git Workflow**: Review docs/roadmap.md and update before commits
- **Check documentation**: Always looks to files like railway-docs-links.md and railpack-docs-links.md for Railway deployment patterns and configurations. Always use railpack and railpack.json setup.

### 5. Version Requirements Enforcement
Maintain awareness of minimum version requirements per project specifications:
- **Node.js**: >=20.0.0 (enforced via yarn.config.cjs constraints)
- **Python**: 3.13 (production via railpack.json)
- **Yarn**: 4.9.2 (exact version via Corepack)
- **TypeScript**: ^5.8.3 (enforced across all workspaces)
- **React**: ^18.2.0 (consistent across workspaces)
- **Next.js**: 15.2.3 (security patched version)
- **ESLint**: ^9.32.0 (unified configuration)
- **Prettier**: ^3.6.2 (consistent formatting)
- **Sentry**: ^9.42.0 (all packages synchronized)
- **Jest**: ^30.0.5 (CLI/SDK), ^29.7.0 (Next.js)
- Prioritize modern, well-supported versions
- Check compatibility before recommendations
- Warn about deprecated technologies

### 6. Build vs. Remove Philosophy
Default to building and completing features rather than removing unused code:
- Investigate thoroughly before suggesting removals
- Prioritize feature completion over cleanup (especially for Phase 1.6 completion)
- Understand project intent through documentation analysis

### 7. Environment-Aware Solutions
Consider different environments (dev, test, prod) and Railway deployment requirements:
- Solutions must work across contexts
- Follow Railway deployment patterns from CLAUDE.md
- Consider Phase 1.6 Authentication System requirements

## Communication & Process Rules

### 8. Clear Task Understanding
Before executing any task, ensure complete understanding by:
- Analyzing for ambiguities
- Asking clarifying questions when needed
- Confirming intent before proceeding
- Gathering relevant context from available sources

### 9. Systematic Investigation Protocol
When troubleshooting or analyzing issues:
- Classify the problem type (build, deploy, runtime, etc.)
- Investigate root causes systematically
- Follow established error pattern recognition
- Provide actionable solutions with clear steps

### 10. Documentation Standards
Always consider documentation impact:
- Update relevant docs when suggesting changes
- Maintain clear change records in docs/roadmap.md
- Provide migration guidance for breaking changes
- Use clear, professional communication
- Reference Agent OS standards (@~/.agent-os/standards/)

## Security & Safety Rules

### 11. Security-First Approach (Critical for Phase 1.6)
Always evaluate security implications, especially for Authentication System Unification:
- Validate input sanitization needs
- Consider authentication/authorization requirements (httpOnly cookies, JWT, session management)
- Never compromise security for convenience
- Review for potential vulnerabilities
- Follow security patterns from CLAUDE.md

### 12. Careful Change Management
Only suggest changes that are:
- Well-understood and related to the request
- Thoroughly analyzed for side effects
- Documented with clear reasoning
- Tested or verifiable when possible
- Aligned with current roadmap priorities

## User Experience & Development Rules

### 13. TypeScript & Modern Development Focus
When providing code solutions:
- Prioritize TypeScript 5.8.3 with strict typing
- Use modern React 18.2.0 patterns (functional components, hooks)
- Use Yarn 4.9.2 exclusively with Corepack (`corepack enable && corepack prepare yarn@4.9.2 --activate`)
- Utilize Yarn workspace features:
  - Run `yarn constraints` to check consistency
  - Use `workspace:*` protocol for internal dependencies
  - Run `yarn npm audit --all` for security checks
  - Leverage global cache and hardlinks for performance
- Use uv then poetry before pip directly for Python 3.13 projects
- Follow established naming conventions from Agent OS standards
- Implement proper error handling and loading states

### 14. Responsive & Accessible Design
Ensure recommendations consider:
- Cross-device compatibility
- Accessibility standards (ARIA attributes)
- Performance optimization
- User experience across different contexts
### 15. Railway Deployment Standards
Follow the 8-step checklist for Railway projects to ensure proper configuration and deployment:
- Pull the latest code
- Open key configuration files
- Verify port usage and binding
- Check inter-service URLs
- CORS configuration review
- WebSocket sanity check
- Dockerfile validation (if used)
  - Use `docker buildx build --builder cloud-garyocean77-superagi .` to use docker build cloud
- Deploy and test loop
- Commit and push changes after verification

### 16. Project Planning Standards
- **Do not include artificial timeframes into plans** - Phases and tasks should be based on complexity and requirements, not arbitrary deadlines
- Align with current roadmap priorities (especially Phase 1.6 Authentication System Unification)
- Reference established patterns from Agent OS documentation

## Railway Config Quick-Check (variable and reference variable Cheat-Sheet)

Follow this 8-step checklist every time you push or deploy a Railway project.

---

### 1. Pull the latest code
```bash
git pull origin main
```

---

### 2. Open the three files that matter
- `railway.toml` or `railway.json`
- `Dockerfile` (if you use one)
- Your main entry file (`server.js`, `app.py`, etc.)

---

### 3. Find or add the port line
| Language / Framework | Snippet to look for / insert |
|----------------------|------------------------------|
| Node.js (Express)    | `app.listen(process.env.PORT || 3000, '0.0.0.0')` |
| Next.js              | `"start": "next start --hostname 0.0.0.0 --port $PORT"` |
| Python (Flask)       | `app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)))` |
| Python (Uvicorn)     | `uvicorn main:app --host 0.0.0.0 --port $PORT` |

üîç **Checklist**
- [ ] Uses `process.env.PORT` / `$PORT` / `os.getenv("PORT")`
- [ ] Binds to `0.0.0.0` (or `::` for IPv6)
- [ ] **No hard-coded port** like `3000` or `5000` alone

---

### 4. Verify inter-service URLs
Replace any hard-coded hostnames or ports with Railway reference variables:

| Instead of ‚Ä¶                     | Use ‚Ä¶ |
|----------------------------------|-------|
| `http://localhost:4000`          | `http://${{api.RAILWAY_PRIVATE_DOMAIN}}:${{api.PORT}}` |
| `https://my-api.example.com`     | `https://${{api.RAILWAY_PUBLIC_DOMAIN}}` |

üîç **Checklist**
- [ ] All internal traffic uses `http://` + `railway.internal` names
- [ ] All public traffic uses `https://` + `RAILWAY_PUBLIC_DOMAIN`
- [ ] **No** plain `localhost`, `127.0.0.1`, or raw IP addresses

---

### 5. CORS quick-scan (backend)
Look for CORS middleware and ensure it contains:

```js
// Node.js / Express example
app.use(cors({
  origin: [process.env.FRONTEND_URL],   // or array of allowed origins
  credentials: true
}));
```

üîç **Checklist**
- [ ] Origin list includes the exact deployed frontend URL(s)
- [ ] `credentials: true` if you send cookies / auth headers
- [ ] **Not** `origin: "*"` in production

---

### 6. WebSocket sanity check
Client-side connection string must match protocol:

| Frontend origin | WebSocket URL |
|-----------------|---------------|
| `https://‚Ä¶`     | `wss://<backend>.up.railway.app/socket.io/` |
| `http://localhost` dev | `ws://localhost:<port>/socket.io/` |

üîç **Checklist**
- [ ] **Never** mix `https` page with `ws://` (blocked by browser)
- [ ] **Server-side** Socket.IO or WS library also has CORS/origin validation

---

### 7. Dockerfile (if used)
Dockerfile should expose the port and accept build-time args:

```dockerfile
ARG PORT
EXPOSE ${PORT}
CMD ["node", "server.js"]
```

üîç **Checklist**
- [ ] Uses `ARG PORT` if you need the port at build time
- [ ] `EXPOSE` matches `$PORT`
- [ ] Final `CMD` starts the app without hard-coding port

---

### 8. Deploy & test loop
```bash
railway up
```
After each deploy:

- Open the **Railway dashboard ‚Üí Service ‚Üí Logs**
- Confirm: `Listening on 0.0.0.0:<PORT>` (or `[::]:<PORT>`)
- Hit the public URL or internal endpoint and verify 200/101 responses
- Check browser console for CORS or WebSocket errors

---

**Done?** ‚úÖ Commit the fixed files and push.

## Critical File Protection Rules (Aligned with CLAUDE.md)

### 17. NEVER MODIFY PROTECTED FILES
The following files are STRICTLY PROTECTED and must NEVER be modified without explicit approval:
- `packages/core/monkey_coder/models.py` - Contains validated AI model configurations critical for system stability
- Any file containing model definitions, API keys, or core provider configurations

**Rationale**: These files contain carefully validated configurations that ensure API compatibility and system stability. Unauthorized modifications can break the entire platform.

**Prohibited Actions**:
- Adding new models or providers
- Modifying existing model names, parameters, or capabilities
- Changing provider configurations or API endpoints
- Updating model limits or pricing information

**If changes are required**: Consult project maintainers and get explicit written approval before making ANY modifications to protected files.

---

*These rules provide structured, thorough, and professional assistance while maintaining high standards for code quality, security, and user experience. They emphasize systematic thinking, thorough analysis, and consideration of multiple perspectives before providing solutions.*

# Railway Deployment Master Cheat Sheet
## Common Pitfalls & Correct Solutions

---

## üî¥ **ISSUE 1: Build System Conflicts**

### **Common Error Pattern:**
```
Nixpacks build failed
ERROR: failed to exec pid1: No such file or directory
```

### **Root Cause:**
Multiple build configurations competing (Dockerfile, railway.toml, railpack.json, nixpacks.toml)

### **Correct Solution:**
```bash
# Railway Build Priority Order (highest to lowest):
# 1. Dockerfile (if exists)
# 2. railpack.json (if exists)
# 3. railway.json/railway.toml
# 4. Nixpacks (auto-detection)

# ENFORCE RAILPACK ONLY:
rm Dockerfile railway.toml nixpacks.toml  # Remove competing configs
touch railpack.json                        # Create railpack config
```

### **Correct railpack.json Template (Yarn Workspace):**
```json
{
  "$schema": "https://schema.railpack.com",
  "provider": "python",  // or "node" for Node.js primary
  "packages": {
    "python": "3.13",
    "node": "20"  // Required for Yarn workspaces
  },
  "steps": {
    "install-yarn": {
      "commands": [
        "corepack enable",
        "corepack prepare yarn@4.9.2 --activate"
      ]
    },
    "build-web": {
      "commands": [
        "yarn install --immutable",
        "yarn workspace @monkey-coder/web build"
      ],
      "inputs": [{"step": "install-yarn"}]
    }
  },
  "deploy": {
    "startCommand": "python run_server.py",  // or "yarn start"
    "inputs": [
      {"local": true, "include": ["packages/**", "yarn.lock", ".yarnrc.yml"]},
      {"step": "build-web"}
    ]
  }
}
```

---

## üî¥ **ISSUE 2: PORT Binding Failures**

### **Common Error Pattern:**
```
Application failed to respond
Health check failed at /api/health
```

### **Root Cause:**
Apps hardcoding ports or binding to localhost instead of 0.0.0.0

### **Correct Solution:**

#### **Node.js/TypeScript:**
```javascript
// ‚úÖ CORRECT
const PORT = process.env.PORT || 3000;
const HOST = '0.0.0.0';  // NOT 'localhost' or '127.0.0.1'
app.listen(PORT, HOST, () => {
  console.log(`Server running on ${HOST}:${PORT}`);
});

// ‚ùå WRONG
app.listen(3000);  // Hardcoded port
app.listen(PORT, 'localhost');  // Wrong host
```

#### **Python:**
```python
# ‚úÖ CORRECT
import os
port = int(os.environ.get("PORT", 5000))
app.run(host="0.0.0.0", port=port)

# ‚ùå WRONG
app.run(host="127.0.0.1", port=5000)  # Wrong host and hardcoded port
```

#### **railpack.json Start Commands:**
```json
{
  "deploy": {
    // ‚úÖ CORRECT
    "startCommand": "node server.js",  // Let app read PORT from env

    // ‚ùå WRONG
    "startCommand": "node server.js --port 3000"  // Hardcoded port
  }
}
```

---

## üî¥ **ISSUE 3: Theme/CSS Loading Issues**

### **Common Error Pattern:**
- Dark mode not persisting
- Tailwind classes not applying
- CSS loading after page render (flash of unstyled content)

### **Root Cause:**
Theme initialization happening after React renders, missing CSS imports

### **Correct Solution:**

#### **1. Pre-React Theme Application:**
```javascript
// src/main.tsx or index.tsx
// ‚úÖ CORRECT - Apply theme BEFORE React renders
document.documentElement.className = localStorage.getItem('theme') || 'dark';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider>
      <App />
    </ThemeProvider>
  </React.StrictMode>
);
```

#### **2. Proper CSS Import Order:**
```css
/* src/index.css */
/* ‚úÖ CORRECT ORDER */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Critical theme styles */
.dark {
  color-scheme: dark;
}

/* Your custom styles AFTER Tailwind */
```

#### **3. Vite Config for Railway:**
```javascript
// vite.config.ts
export default defineConfig({
  base: './',  // Relative paths for Railway
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    // Ensure CSS is bundled
    cssCodeSplit: false
  }
});
```

---

## üî¥ **ISSUE 4: Reference Variable Mistakes**

### **Common Error Pattern:**
```
"Install inputs must be an image or step input"
"serviceA.PORT does not resolve"
```

### **Root Cause:**
Misunderstanding Railway's reference variable system

### **Correct Solution:**

#### **‚ùå WRONG - Common Mistakes:**
```bash
# Cannot reference PORT of another service
BACKEND_URL=${{backend.PORT}}

# Wrong inputs field in railpack.json install step
"install": {
  "inputs": [{"step": "setup"}],  # Install doesn't need inputs
  "commands": ["pip install -r requirements.txt"]
}
```

#### **‚úÖ CORRECT - Proper References:**
```bash
# Reference public domain (Railway provides)
BACKEND_URL=https://${{backend.RAILWAY_PUBLIC_DOMAIN}}

# Reference private domain for internal communication
INTERNAL_API=http://${{backend.RAILWAY_PRIVATE_DOMAIN}}

# Railway automatically provides PORT - don't set manually
# Let Railway inject PORT, app reads from process.env.PORT
```

---

## üî¥ **ISSUE 5: Health Check Configuration**

### **Common Error Pattern:**
```
Health check failed: service unavailable
```

### **Correct Solution:**

#### **1. Add Health Endpoint:**
```javascript
// Express.js
app.get('/api/health', (req, res) => {
  res.status(200).json({ status: 'healthy' });
});

// Python Flask
@app.route('/api/health')
def health():
    return jsonify({'status': 'healthy'}), 200
```

#### **2. Configure in railpack.json:**
```json
{
  "deploy": {
    "healthCheckPath": "/api/health",
    "healthCheckTimeout": 300,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 3
  }
}
```

---

## üî¥ **ISSUE 6: Monorepo Service Confusion**

### **Common Error Pattern:**
```
Nixpacks unable to generate build plan
Multiple services detected
```

### **Correct Solution:**

#### **Separate railpack.json for Each Service:**
```bash
# Project structure
/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îî‚îÄ‚îÄ railpack.json  # Backend-specific config
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îî‚îÄ‚îÄ railpack.json  # Frontend-specific config
‚îî‚îÄ‚îÄ railpack.json      # Root config (if needed)
```

#### **Root railpack.json for Monorepo:**
```json
{
  "version": "1",
  "services": {
    "backend": {
      "root": "./backend",
      "build": {
        "provider": "python"
      }
    },
    "frontend": {
      "root": "./frontend",
      "build": {
        "provider": "node"
      }
    }
  }
}
```

---

## üìã **Pre-Deployment Validation Checklist**

```bash
# 1. Check for conflicting build configs
ls -la | grep -E "(Dockerfile|railway\.toml|nixpacks\.toml|railpack\.json)"

# 2. Validate railpack.json syntax
cat railpack.json | jq '.' > /dev/null && echo "‚úÖ Valid JSON"

# 3. Verify PORT usage in code
grep -r "process.env.PORT\|PORT" . | grep -v node_modules

# 4. Check host binding
grep -r "0\.0\.0\.0\|localhost\|127\.0\.0\.1" . | grep -E "(listen|HOST|host)"

# 5. Verify health endpoint exists
grep -r "/health\|/api/health" . | grep -v node_modules

# 6. Test build locally
yarn build && PORT=3000 yarn start

# 7. Create git hook for validation
cat > .git/hooks/pre-push << 'EOF'
#!/bin/bash
if [ -f railpack.json ]; then
  jq '.' railpack.json > /dev/null || exit 1
fi
EOF
chmod +x .git/hooks/pre-push
```

---

## üöÄ **Quick Fix Commands**

```bash
# Force Railpack rebuild
railway up --force

# Clear Railway build cache
railway run --service <service-name> railway cache:clear

# Debug environment variables
railway run env | grep -E "(PORT|HOST|RAILWAY)"

# Test health endpoint
railway run curl http://localhost:$PORT/api/health
```

---

## üìù **Add to Your Coding Assistant Rules**

```markdown
## Railway Deployment Standards

1. **Always use railpack.json** as the primary build configuration
2. **Never hardcode ports** - always use process.env.PORT
3. **Always bind to 0.0.0.0** not localhost or 127.0.0.1
4. **Apply theme before React renders** to prevent flash of unstyled content
5. **Reference domains not ports** in Railway variables (${{service.RAILWAY_PUBLIC_DOMAIN}})
6. **Include health check endpoint** at /api/health returning 200 status
7. **Remove competing build files** (Dockerfile, railway.toml) when using railpack.json
8. **Test locally with Railway environment**: railway run yarn dev
9. **Validate JSON syntax** before committing railpack.json
10. **Use inputs field only for layer references** in railpack.json, not for basic installs
```

This cheat sheet addresses the recurring issues I found across your Railway projects. Add these rules to your coding assistant configuration to prevent these issues from happening again.
