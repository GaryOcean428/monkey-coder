# Production Architecture - Monkey Coder

## Overview

Monkey Coder uses a **centralized API gateway architecture** in production where:
1. **CLI/SDK clients** authenticate with the deployed Monkey Coder API
2. **Monkey Coder API** (deployed on Railway) acts as the gateway
3. **The gateway** makes calls to AI providers (OpenAI, Anthropic, Groq, etc.)
4. **Responses** flow back through the gateway to clients

This architecture provides centralized billing, usage tracking, security, and model routing.

## Architecture Flow

```mermaid
graph LR
    subgraph "Client Side"
        CLI[CLI Tool]
        SDK[SDK/Library]
        WEB[Web App]
    end
    
    subgraph "Production API (Railway)"
        AUTH[Authentication]
        ROUTER[Model Router]
        QUANTUM[Quantum Executor]
        BILLING[Usage Tracking]
        CACHE[Response Cache]
    end
    
    subgraph "AI Providers"
        OPENAI[OpenAI API]
        ANTHROPIC[Anthropic API]
        GROQ[Groq API]
        GOOGLE[Google API]
        GROK[Grok/xAI API]
    end
    
    CLI --> AUTH
    SDK --> AUTH
    WEB --> AUTH
    
    AUTH --> ROUTER
    ROUTER --> QUANTUM
    QUANTUM --> BILLING
    
    QUANTUM --> OPENAI
    QUANTUM --> ANTHROPIC
    QUANTUM --> GROQ
    QUANTUM --> GOOGLE
    QUANTUM --> GROK
    
    BILLING --> CACHE
    CACHE --> CLI
    CACHE --> SDK
    CACHE --> WEB
```

## Detailed Flow

### 1. Client Authentication
```bash
# CLI authenticates with Monkey Coder API
monkey auth login --email user@example.com --password pass

# This returns an API key like: mk-dev-EeSR4-BBpJsUTZCgIUjbdN3...
# The CLI stores this locally and uses it for all requests
```

### 2. Client Makes Request
```bash
# User runs a command
monkey implement "create a REST API"

# CLI sends request to production API
POST https://coder.fastmonkey.au/v1/execute
Authorization: Bearer mk-dev-EeSR4-BBpJsUTZCgIUjbdN3...
{
  "task_type": "code_generation",
  "prompt": "create a REST API",
  "persona": "backend",
  "preferred_providers": ["groq", "openai"]
}
```

### 3. Production API Processing

The deployed API on Railway:

```python
# monkey_coder/app/main.py
@app.post("/v1/execute")
async def execute_task(
    request: ExecuteRequest,
    api_key: str = Depends(get_api_key),  # Validates mk-* key
    background_tasks: BackgroundTasks
):
    # 1. Validate user authentication
    user = await get_user_by_api_key(api_key)
    
    # 2. Check usage limits and billing
    if not await check_usage_limits(user):
        raise HTTPException(402, "Usage limit exceeded")
    
    # 3. Route to optimal AI provider
    provider = await quantum_executor.select_optimal_provider(
        task_type=request.task_type,
        persona=request.persona,
        preferred_providers=request.preferred_providers
    )
    
    # 4. Make API call to selected provider (e.g., Groq)
    result = await provider.generate_completion(
        model=selected_model,
        messages=formatted_messages,
        **request.model_config
    )
    
    # 5. Track usage for billing
    background_tasks.add_task(
        track_usage,
        user_id=user.id,
        provider=provider.name,
        tokens=result.usage
    )
    
    # 6. Return response to client
    return ExecuteResponse(
        content=result.content,
        provider_used=provider.name,
        model_used=selected_model,
        usage=result.usage
    )
```

### 4. Provider API Keys Management

In production, the API keys are stored as environment variables on Railway:

```bash
# Railway Environment Variables (stored securely)
OPENAI_API_KEY=sk-proj-xxxxx       # OpenAI key
ANTHROPIC_API_KEY=sk-ant-xxxxx     # Anthropic key  
GROQ_API_KEY=gsk_xxxxx             # Groq key
GOOGLE_API_KEY=AIzaSyxxxxx         # Google key
GROK_API_KEY=xai-xxxxx             # xAI/Grok key

# These are NEVER exposed to clients
# Only the Monkey Coder API uses them
```

## Security & Isolation

### API Key Hierarchy

1. **Client API Keys** (`mk-*` prefix)
   - Generated by Monkey Coder for users
   - Used to authenticate with Monkey Coder API
   - Tied to user accounts and billing

2. **Provider API Keys** (`sk-*`, `gsk_*`, etc.)
   - Stored only on production server
   - Never exposed to clients
   - Used by Monkey Coder to call AI providers

### Security Benefits

- **Key Protection**: Provider API keys are never exposed to end users
- **Usage Control**: Centralized rate limiting and usage tracking
- **Billing**: All usage goes through Monkey Coder for accurate billing
- **Audit Trail**: Complete logging of all AI requests
- **Model Access**: Users get access to all models without managing multiple keys

## Railway Deployment Configuration

### Current Deployment
```yaml
# Railway deployment (production)
RAILWAY_PUBLIC_DOMAIN=coder.fastmonkey.au  # Custom domain
RAILWAY_SERVICE_URL=monkey-coder.up.railway.app  # Railway domain
DATABASE_URL=postgresql://postgres.railway.internal:5432/railway
REDIS_URL=redis://default:xxx@gondola.proxy.rlwy.net:45640
```

### Environment Setup on Railway
```bash
# Production environment variables on Railway
NODE_ENV=production
ENVIRONMENT=production
PORT=8000  # Railway provides this

# AI Provider Keys (stored securely in Railway)
OPENAI_API_KEY=<actual_key>
ANTHROPIC_API_KEY=<actual_key>
GROQ_API_KEY=<actual_key>
GOOGLE_API_KEY=<actual_key>
GROK_API_KEY=<actual_key>

# Security
JWT_SECRET_KEY=<generated_secret>
STRIPE_SECRET_KEY=<stripe_key>

# Database (Railway provides these)
DATABASE_URL=<railway_postgresql_url>
REDIS_URL=<railway_redis_url>
```

## Client Configuration

### CLI Configuration
```bash
# ~/.config/monkey-coder/config.json
{
  "apiKey": "mk-dev-EeSR4-BBpJsUTZCgIUjbdN3...",
  "baseUrl": "https://coder.fastmonkey.au",
  "defaultPersona": "developer",
  "defaultProvider": "groq"  # Preference, not direct access
}
```

### SDK Configuration
```python
# Python SDK
from monkey_coder import MonkeyCoderClient

client = MonkeyCoderClient(
    api_key="mk-dev-EeSR4-BBpJsUTZCgIUjbdN3...",
    base_url="https://coder.fastmonkey.au"
)

# The SDK calls the Monkey Coder API, not providers directly
response = await client.execute(
    prompt="Create a REST API",
    persona="backend"
)
```

## Billing & Usage Tracking

### Usage Flow
1. **Client Request** → Monkey Coder API
2. **API tracks**: User ID, timestamp, task type
3. **Provider Call** → Get token usage
4. **Billing Update**: Store usage in database
5. **Stripe Integration**: Monthly billing based on usage

### Database Schema
```sql
-- Usage tracking
CREATE TABLE usage_records (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    timestamp TIMESTAMP,
    provider VARCHAR(50),
    model VARCHAR(100),
    prompt_tokens INTEGER,
    completion_tokens INTEGER,
    total_cost DECIMAL(10, 6)
);

-- User API keys (mk-* keys)
CREATE TABLE api_keys (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    key_hash VARCHAR(255),  -- Hashed mk-* key
    name VARCHAR(100),
    created_at TIMESTAMP,
    last_used TIMESTAMP
);
```

## Advantages of This Architecture

### For Users
- **Single API Key**: One `mk-*` key for all AI providers
- **No Provider Management**: Don't need OpenAI, Anthropic, Groq accounts
- **Unified Billing**: Single invoice for all AI usage
- **Better Reliability**: Automatic failover between providers
- **Advanced Features**: Quantum routing, caching, optimization

### For Monkey Coder
- **Revenue Model**: Markup on AI provider costs
- **Usage Analytics**: Understand how users use different models
- **Quality Control**: Monitor and optimize model selection
- **Security**: Protect provider API keys
- **Innovation**: Add features like caching, fine-tuning, plugins

## Development vs Production

### Development (Local)
```bash
# .env.local (for local development)
OPENAI_API_KEY=your_personal_key
GROQ_API_KEY=your_personal_key
# Direct provider access for testing
```

### Production (Railway)
```bash
# Railway environment (secured)
OPENAI_API_KEY=company_production_key
GROQ_API_KEY=company_production_key
# Centralized access through API
```

## API Endpoints

### Core Endpoints
- `POST /v1/execute` - Execute AI task with routing
- `GET /v1/models` - List available models
- `GET /v1/providers` - List available providers
- `POST /v1/auth/login` - User authentication
- `GET /v1/billing/usage` - Get usage statistics
- `POST /v1/billing/checkout` - Create Stripe checkout session

### Health & Monitoring
- `GET /health` - API health check
- `GET /v1/capabilities` - System capabilities
- `GET /metrics` - Prometheus metrics

## Conclusion

The production architecture ensures:
1. **Security**: Provider API keys are never exposed
2. **Scalability**: Centralized API can handle load balancing
3. **Monetization**: Usage-based billing through Stripe
4. **Reliability**: Failover and caching mechanisms
5. **Innovation**: Quantum routing and optimization features

Users interact only with the Monkey Coder API using their `mk-*` keys, while the backend handles all provider interactions securely and efficiently.